# Файл docker-compose должен начинаться с тега версии.
# Мы используем "3" так как это - самая свежая версия на момент написания этого кода.

version: "3"

# Следует учитывать, что docker-composes работает с сервисами.
# 1 сервис = 1 контейнер.
# Сервисом может быть клиент, сервер, сервер баз данных...
# Раздел, в котором будут описаны сервисы, начинается с 'services'.

services:

  # Как уже было сказано, мы собираемся создать клиентское и серверное приложения.
  # Это означает, что нам нужно два сервиса.
  # Первый сервис (контейнер): app.
  # Назвать его можно так, как нужно разработчику.
  # Понятное название сервиса помогает определить его роль.
  # Здесь мы, для именования соответствующего сервиса, используем ключевое слово 'app'.

  app:
     # Ключевое слово 'depends_on' позволяет указывать, должен ли сервис,
    # прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы.
    # Нам нужно, чтобы сервис 'app' дождался бы готовности к работе сервиса 'db'.
    env_file:
      - .env

    image: valdemarsu/${APP_NAME}-app:latest

    depends_on:
      - db

    # links:
    #   - db

    # Ключевое слово "build" позволяет задать
    # путь к файлу Dockerfile, который нужно использовать для создания образа,
    # который позволит запустить сервис.
    # Здесь 'context' соответствует пути к папке app,
    # которая содержит соответствующий Dockerfile.

    build: 
      context: ./
      dockerfile: Dockerfile
      args:
        PORT: ${PORT}

    develop:
      watch:
        # - action: sync+restart
        #   path: ./.env
        #   target: /usr/src/app/.env  
        - action: rebuild
          path: ./src
          target: /usr/src/app/src          
        # - action: rebuild
        #   path: package.json
    # restart: always
    restart: unless-stopped    

    # Команда, которую нужно запустить после создания образа.
    # Следующая команда означает запуск "python ./server.py".

    # command: python ./server.py

    # Вспомните о том, что в качестве порта в 'server/server.py' указан порт 1234.
    # Если мы хотим обратиться к серверу с нашего компьютера (находясь за пределами контейнера),
    # мы должны организовать перенаправление этого порта на порт компьютера.
    # Сделать это нам поможет ключевое слово 'ports'.
    # При его использовании применяется следующая конструкция: [порт компьютера]:[порт контейнера]
    # В нашем случае нужно использовать порт компьютера 1234 и организовать его связь с портом
    # 1234 контейнера (так как именно на этот порт сервер 
    # ожидает поступления запросов).

    ports:
      - ${PORT}:${PORT}

    networks:
      - appnet

    volumes:
      - ./logs:/var/log


  # Второй сервис (контейнер): база данных.
  # Этот сервис назван 'db'.

  db:
    env_file:
      - .env
    
    image: valdemarsu/${APP_NAME}-db:latest

    # Здесь context соответствует пути к папке, которая содержит
    # файл Dockerfile для db части системы. Если надо его пересобирать

    build:     
      context: ./src/db/pg
      dockerfile: Dockerfile
      args:
        POSTGRES_EXPOSE: ${POSTGRES_EXPOSE}

    # restart: always
    restart: unless-stopped

    ports:
      - ${POSTGRES_PORT}:${POSTGRES_EXPOSE}

    # Ключевое слово 'volumes' позволяет задать пути к директориям,
    # которые будут доступны внутри образа.
    # В нашем случае мы создаем образ с директориями, в которых будут храниться
    # данные для подключения к базе данных.

    volumes:
      - ./db_data:/var/lib/postgresql/data
      - ./logs:/var/log

    # Команда, которую нужно запустить после создания образа.
 
    # command: python ./client.py

    # Ключевое слово 'network_mode' используется для описания типа сети.
    # Тут мы указываем то, что контейнер может обращаться к 'localhost' компьютера.

    # network_mode: host

    networks:
      - appnet

# Ключевое слово 'volumes' позволяет задать пути к директориям,
# которые будут доступны внутри службы.
volumes:
  db_data:
     driver: local
  logs:
     driver: local

networks:
  appnet:
    driver: bridge

    